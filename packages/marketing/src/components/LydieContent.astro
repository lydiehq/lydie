---
import { getImage } from "astro:assets";
import type { ContentNode } from "@lydie/core/content";
import {
  renderContent,
  type ImageComponentProps,
  blogImageComponent,
} from "../utils/content-renderer";
import {
  flowchartComponent,
  pillarCalloutComponent,
} from "../utils/custom-components";
import { FAQ, type FAQItem } from "./generic/FAQ";

interface Props {
  content: ContentNode;
  linkPrefix?: string;
  linkResolver?: (ref: {
    href: string;
    id?: string;
    slug?: string;
    title?: string;
    parentId?: string;
    parentSlug?: string;
    collectionHandle?: string;
    type?: "internal" | "external";
  }) => string;
}

const { content, linkPrefix, linkResolver } = Astro.props;

type FAQBlock = {
  title?: string;
  items: FAQItem[];
};

type ContentSegment =
  | {
      type: "html";
      html: string;
    }
  | {
      type: "faq";
      block: FAQBlock;
    };

const FAQ_PLACEHOLDER_PREFIX = "lydie-faq-block";

function getString(value: unknown): string {
  return typeof value === "string" ? value : "";
}

function getFaqItems(value: unknown): FAQItem[] {
  if (!Array.isArray(value)) return [];

  return value
    .map((item): FAQItem | null => {
      if (!item || typeof item !== "object") return null;

      const question = getString((item as Record<string, unknown>).question).trim();
      const answer = getString((item as Record<string, unknown>).answer).trim();

      if (!question || !answer) return null;

      return { question, answer };
    })
    .filter((item): item is FAQItem => Boolean(item));
}

function createFaqPlaceholder(index: number): string {
  return `<div data-${FAQ_PLACEHOLDER_PREFIX}="${index}"></div>`;
}

function getFaqIndexFromPlaceholder(match: string): number | null {
  const indexMatch = match.match(/"(\d+)"/);
  if (!indexMatch) return null;

  const index = Number(indexMatch[1]);
  return Number.isNaN(index) ? null : index;
}

function splitIntoSegments(html: string, faqBlocks: FAQBlock[]): ContentSegment[] {
  const segments: ContentSegment[] = [];
  const placeholderRegex = new RegExp(
    `<div data-${FAQ_PLACEHOLDER_PREFIX}="\\d+"></div>`,
    "g",
  );

  let lastIndex = 0;
  let match: RegExpExecArray | null;

  while ((match = placeholderRegex.exec(html)) !== null) {
    const matchStart = match.index;
    const matchEnd = match.index + match[0].length;

    if (matchStart > lastIndex) {
      const segmentHtml = html.slice(lastIndex, matchStart);
      if (segmentHtml) {
        segments.push({ type: "html", html: segmentHtml });
      }
    }

    const faqIndex = getFaqIndexFromPlaceholder(match[0]);
    if (faqIndex !== null) {
      const block = faqBlocks[faqIndex];
      if (block) {
        segments.push({ type: "faq", block });
      }
    }

    lastIndex = matchEnd;
  }

  if (lastIndex < html.length) {
    const segmentHtml = html.slice(lastIndex);
    if (segmentHtml) {
      segments.push({ type: "html", html: segmentHtml });
    }
  }

  if (segments.length === 0 && html) {
    segments.push({ type: "html", html });
  }

  return segments;
}

// Custom image component that uses Astro's Image optimization
async function astroImageComponent(props: ImageComponentProps): Promise<string> {
  const { src, alt, title, width, height } = props;

  try {
    const optimized = await getImage({
      src,
      alt: alt || "",
      width: width || 800,
      height: height || 600,
      inferSize: !width || !height,
      format: "webp",
      quality: 80,
    });

    const altAttr = alt ? ` alt="${alt}"` : "";
    const titleAttr = title ? ` title="${title}"` : "";
    const widthAttr = optimized.attributes?.width
      ? ` width="${optimized.attributes.width}"`
      : "";
    const heightAttr = optimized.attributes?.height
      ? ` height="${optimized.attributes.height}"`
      : "";
    const srcset = optimized.srcSet?.attribute
      ? ` srcset="${optimized.srcSet.attribute}"`
      : "";
    // Blog content is in max-w-2xl container (~672px), so use appropriate sizes
    const sizes = ` sizes="(max-width: 672px) 100vw, 672px"`;

    return `<div class="my-6 flex justify-center">
      <img
        src="${optimized.src}"
        ${srcset}${sizes}${altAttr}${titleAttr}${widthAttr}${heightAttr}
        class="rounded-lg border border-black/8 max-w-full h-auto"
        loading="lazy"
        decoding="async"
      />
    </div>`;
  } catch (error) {
    // Fallback to blog image component if optimization fails
    console.warn(`[LydieContent] Failed to optimize image: ${src}`, error);
    return blogImageComponent(props);
  }
}

const faqBlocks: FAQBlock[] = [];

function faqPlaceholderComponent(properties: Record<string, unknown>): string {
  const title = getString(properties.title).trim() || undefined;
  const items = getFaqItems(properties.items);

  if (items.length === 0) {
    return "";
  }

  const index = faqBlocks.push({ title, items }) - 1;
  return createFaqPlaceholder(index);
}

// First pass: render content to get HTML and image list
const { html, images } = await renderContent(content, {
  linkPrefix,
  linkResolver,
  components: {
    image: blogImageComponent,
    pillarCallout: pillarCalloutComponent,
    flowchart: flowchartComponent,
    faq: faqPlaceholderComponent,
    FAQ: faqPlaceholderComponent,
  },
});

// Create a map of optimized images
const optimizedImages = new Map<string, string>();
for (const image of images) {
  optimizedImages.set(image.src, await astroImageComponent(image));
}

// Replace image placeholders in HTML with optimized versions
let finalHtml = html;
for (const [originalSrc, optimizedHtml] of optimizedImages) {
  const escapedSrc = originalSrc.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  const blogPattern = new RegExp(
    `<div class="my-6 flex justify-center">\\s*<img[^>]*src="${escapedSrc}"[^>]*/?>\\s*</div>`,
    "g",
  );
  finalHtml = finalHtml.replace(blogPattern, optimizedHtml);
}

const segments = splitIntoSegments(finalHtml, faqBlocks);
---

{
  segments.map((segment) =>
    segment.type === "faq" ? (
      <FAQ title={segment.block.title} items={segment.block.items} client:visible />
    ) : (
      <Fragment set:html={segment.html} />
    ),
  )
}
