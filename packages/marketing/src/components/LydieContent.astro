---
import { renderWithBuilder } from "@lydie/core/content";
import type { ContentNode } from "@lydie-app/sdk";
import {
  ShikiHTMLSerializer,
  extractCodeText,
} from "../utils/shiki-html-serializer";

interface Props {
  content: ContentNode;
  linkPrefix?: string;
  linkResolver?: (ref: {
    href: string;
    id?: string;
    slug?: string;
    title?: string;
    type?: "internal" | "external";
  }) => string;
}

const { content, linkPrefix, linkResolver } = Astro.props;

// Process code blocks with Shiki, then render the rest with the standard serializer
async function processCodeBlocks(
  node: ContentNode | any,
): Promise<ContentNode | any> {
  if (node.type === "codeBlock") {
    // Leave code blocks as-is, we'll process them separately
    return node;
  }

  if (node.content && Array.isArray(node.content)) {
    return {
      ...node,
      content: await Promise.all(node.content.map(processCodeBlocks)),
    };
  }

  return node;
}

// Render content, processing code blocks with Shiki
async function renderContentWithShiki(
  node: ContentNode | any,
): Promise<string> {
  const serializer = new ShikiHTMLSerializer({ linkPrefix, linkResolver });

  // First, render everything using the standard builder
  // But we need to handle code blocks specially
  async function renderNode(n: ContentNode | any): Promise<string> {
    if (n.type === "text") {
      return renderMarks(n.text, n.marks, serializer);
    }

    if (!n.content || !Array.isArray(n.content)) {
      return serializer.empty();
    }

    const children = await Promise.all(n.content.map(renderNode));

    switch (n.type) {
      case "doc":
        return serializer.doc(children);
      case "paragraph":
        return serializer.paragraph(children);
      case "heading":
        return serializer.heading(n.attrs?.level || 1, children);
      case "bulletList":
        return serializer.bulletList(children);
      case "orderedList":
        return serializer.orderedList(children, n.attrs?.start);
      case "listItem":
        return serializer.listItem(children);
      case "horizontalRule":
        return serializer.horizontalRule();
      case "blockquote":
        return serializer.blockquote(children);
      case "codeBlock": {
        // Extract raw code text and process with Shiki
        const rawCode = extractCodeText(n);
        return await serializer.codeBlockWithShiki(
          [rawCode],
          n.attrs?.language,
        );
      }
      case "customBlock":
        return serializer.customBlock(
          n.attrs?.name || "",
          n.attrs?.properties || {},
        );
      case "documentComponent":
        return serializer.customBlock(
          n.attrs?.name || "",
          n.attrs?.properties || {},
        );
      default:
        return serializer.empty();
    }
  }

  return await renderNode(node);
}

// Handle marks (bold, italic, links, etc.)
function renderMarks(
  text: string,
  marks: any[] | undefined,
  serializer: ShikiHTMLSerializer,
): string {
  if (!marks || marks.length === 0) {
    return serializer.text(text);
  }

  return marks.reduce((wrapped: string, mark) => {
    if (!mark || typeof mark !== "object" || !mark.type) {
      return wrapped;
    }

    switch (mark.type) {
      case "bold":
        return serializer.bold(wrapped);
      case "italic":
        return serializer.italic(wrapped);
      case "link":
        return serializer.link(
          wrapped,
          mark.attrs?.href,
          mark.attrs?.rel,
          mark.attrs?.target,
        );
      case "internal-link":
        return serializer.internalLink(
          wrapped,
          mark.attrs?.["document-id"],
          mark.attrs?.["document-slug"],
          mark.attrs?.["document-title"],
        );
      default:
        return wrapped;
    }
  }, serializer.text(text));
}

const html = await renderContentWithShiki(content);
---

<div set:html={html} />
